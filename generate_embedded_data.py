import os
import sys
import binascii

def generate_embedded_data(projects_root_dir, output_header_path="embedded_data.h"):
    """
    Generates a C++ header file containing embedded project data.
    """
    embedded_files_map = {}  # { relative_path: { data_var_name, size_var_name } }
    embedded_data_vars = []  # List of C++ unsigned char array definitions
    embedded_directories = set() # Use a set to avoid duplicates

    if not os.path.exists(projects_root_dir):
        print(f"Error: Projects directory '{projects_root_dir}' not found.", file=sys.stderr)
        sys.exit(1)

    # Traverse the Projects directory
    for root, dirs, files in os.walk(projects_root_dir):
        # Add all directories to the set
        for d in dirs:
            rel_path = os.path.relpath(os.path.join(root, d), os.path.dirname(projects_root_dir))
            embedded_directories.add(rel_path.replace("\\", "/")) # Ensure forward slashes

        for file_name in files:
            file_path = os.path.join(root, file_name)
            # Create a C++ friendly variable name
            data_var_name = "embedded_" + file_path.replace(os.sep, "_").replace(".", "_").replace("-", "_")
            size_var_name = data_var_name + "_size"

            # Read file content as binary
            try:
                with open(file_path, 'rb') as f:
                    content = f.read()
            except IOError:
                print(f"Warning: Could not read file '{file_path}'. Skipping.", file=sys.stderr)
                continue

            hex_content = binascii.hexlify(content).decode('utf-8')
            c_array_elements = [f"0x{hex_content[i:i+2]}" for i in range(0, len(hex_content), 2)]
            c_array_str = ",\n    ".join(c_array_elements)

            embedded_data_vars.append(
                f"    const unsigned char {data_var_name}[] = {{\n        {c_array_str}\n    }};"
            )
            embedded_data_vars.append(
                f"    const size_t {size_var_name} = {len(content)};"
            )

            relative_file_path = os.path.relpath(file_path, os.path.dirname(projects_root_dir))
            # Use forward slashes for paths in map keys, as C++ std::filesystem prefers it and it's cross-platform
            embedded_files_map[relative_file_path.replace("\\", "/")] = {
                "data_var": data_var_name,
                "size_var": size_var_name
            }

    # Sort directories for consistent order during creation
    sorted_dirs = sorted(list(embedded_directories))

    with open(output_header_path, 'w') as f:
        f.write("// This file is auto-generated by generate_embedded_data.py\n")
        f.write("#pragma once\n\n")
        f.write("#include <vector>\n")
        f.write("#include <string>\n")
        f.write("#include <map>\n")
        f.write("#include <filesystem>\n\n")

        f.write("namespace EmbeddedData {\n")

        # Write all embedded data variables
        for var_def in embedded_data_vars:
            f.write(var_def + "\n")
        f.write("\n")

        # Write the map of embedded files
        f.write("    const std::map<std::string, std::pair<const unsigned char*, size_t>> embedded_files = {\n")
        for rel_path, vars_info in embedded_files_map.items():
            # Corrected line: double the curly braces for the pair initialization
            f.write(f"        {{\"{rel_path}\", {{{vars_info['data_var']}, {vars_info['size_var']}}}}},\n")
        f.write("    };\n\n")

        # Write the list of directories
        f.write("    const std::vector<std::string> embedded_directories = {\n")
        for dir_path in sorted_dirs:
            f.write(f"        \"{dir_path}\",\n")
        f.write("    };\n")

        f.write("} // namespace EmbeddedData\n")

    print(f"Successfully generated '{output_header_path}' with data from '{projects_root_dir}'.")

if __name__ == "__main__":
    generate_embedded_data("Projects")